# SendSign Helm Chart — Default Values
# Override these in your values-production.yaml or via --set flags

replicaCount: 2

image:
  repository: ghcr.io/sendsign/sendsign
  tag: "latest"
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# ─── Application Configuration ───────────────────────────────────────

config:
  # Base URL for the SendSign instance (used in signing links)
  baseUrl: "https://sign.example.com"
  # Log level: debug, info, warn, error
  logLevel: "info"
  # Node environment
  nodeEnv: "production"
  # Port the app listens on
  port: 3000

# ─── Database ────────────────────────────────────────────────────────

database:
  # Connection string (use externalSecret for production)
  url: ""
  # Or use individual fields
  host: ""
  port: 5432
  name: "sendsign"
  user: "sendsign"
  password: ""
  ssl: true

# ─── Storage (S3-compatible) ────────────────────────────────────────

storage:
  endpoint: ""
  region: "us-east-1"
  bucket: "sendsign-documents"
  accessKeyId: ""
  secretAccessKey: ""
  forcePathStyle: false

# ─── Encryption ─────────────────────────────────────────────────────

encryption:
  # AES-256-GCM key for document encryption at rest
  key: ""

# ─── API Authentication ─────────────────────────────────────────────

auth:
  # Default API key (for single-tenant mode; multi-tenant uses api_keys table)
  apiKey: ""

# ─── Email (SendGrid) ───────────────────────────────────────────────

email:
  sendgridApiKey: ""
  fromAddress: "noreply@sign.example.com"
  fromName: "SendSign"

# ─── SMS (Twilio) ───────────────────────────────────────────────────

sms:
  twilioAccountSid: ""
  twilioAuthToken: ""
  twilioFromNumber: ""

# ─── External Secrets ───────────────────────────────────────────────
# Use external secret managers (AWS Secrets Manager, Vault, etc.)

externalSecret:
  enabled: false
  # Name of the ExternalSecret or SecretStore resource
  secretStoreName: ""
  # Refresh interval
  refreshInterval: "1h"

# ─── Service ────────────────────────────────────────────────────────

service:
  type: ClusterIP
  port: 80
  targetPort: 3000

# ─── Ingress ────────────────────────────────────────────────────────

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
  hosts:
    - host: sign.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: sendsign-tls
      hosts:
        - sign.example.com

# ─── Autoscaling ────────────────────────────────────────────────────

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# ─── Resources ──────────────────────────────────────────────────────

resources:
  requests:
    cpu: 250m
    memory: 256Mi
  limits:
    cpu: 1000m
    memory: 512Mi

# ─── Pod Disruption Budget ──────────────────────────────────────────

podDisruptionBudget:
  enabled: true
  minAvailable: 1

# ─── Cron Jobs ──────────────────────────────────────────────────────

cronJobs:
  # Retention policy processing
  retention:
    enabled: true
    schedule: "0 2 * * *"  # Daily at 2 AM
  # Reminder emails
  reminders:
    enabled: true
    schedule: "0 9 * * *"  # Daily at 9 AM
  # Expiry checks
  expiry:
    enabled: true
    schedule: "0 * * * *"  # Every hour

# ─── Health Checks ──────────────────────────────────────────────────

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 15
  periodSeconds: 20
  timeoutSeconds: 5

readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3

# ─── Node Selector / Tolerations / Affinity ─────────────────────────

nodeSelector: {}
tolerations: []
affinity: {}

# ─── Pod Annotations ────────────────────────────────────────────────

podAnnotations: {}
podLabels: {}

serviceAccount:
  create: true
  annotations: {}
  name: ""
